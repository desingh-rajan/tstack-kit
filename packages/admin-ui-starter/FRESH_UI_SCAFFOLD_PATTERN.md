# Fresh UI Scaffold Pattern - tstack-kit

**Template for generating DRY, config-driven CRUD UI**

This document defines the scaffolding pattern for `tstack ui-scaffold {entity}`
command.

## Overview

The scaffold generates a complete CRUD interface by creating:

1. **Entity configuration** file (defines all fields)
2. **4 route files** (list, show, create, edit)

All UI logic is handled by **generic reusable components**:

- `DataTable` - Shows ALL columns
- `ShowPage` - Shows ALL fields
- `GenericForm` - Generates forms
- `Pagination` - Page navigation

## Command Usage

```bash
tstack ui-scaffold posts
tstack ui-scaffold comments
tstack ui-scaffold categories --key-based  # Use 'slug' instead of 'id'
```

## Generated Files

For entity `posts`, scaffold generates:

```plaintext
config/entities/posts.config.tsx       # Entity configuration
routes/admin/posts/index.tsx          # List page
routes/admin/posts/[id].tsx           # Show page
routes/admin/posts/new.tsx            # Create page
routes/admin/posts/[id]/edit.tsx      # Edit page
```

---

## Template 1: Entity Configuration

**File**: `config/entities/{entity}.config.tsx`

```typescript
/**
 * {Entity} Entity Configuration
 * Generated by tstack ui-scaffold
 */

import type { EntityConfig } from "@/lib/admin/types.ts";
import type { {Entity} } from "@/entities/{entities}/{entity}.types.ts";
import { {entity}Service } from "@/entities/{entities}/{entity}.service.ts";

export const {entity}Config: EntityConfig<{Entity}> = {
  // Basic info
  name: "{entities}",              // URL path: /admin/{entities}
  singularName: "{Entity}",        // Display: "Article"
  pluralName: "{Entities}",        // Display: "Articles"
  apiPath: "/ts-admin/{entities}", // Backend API path
  idField: "id",                   // Primary key field (or "key", "slug")

  // UI customization
  displayField: "title",           // Field to show as record title
  descriptionField: "slug",        // Field to show as subtitle

  // Service
  service: {entity}Service,

  // Fields configuration
  fields: [
    {
      name: "id",
      label: "ID",
      type: "number",
      showInList: true,
      showInShow: true,
      showInForm: false,
      sortable: true,
    },
    // Add more fields based on entity schema
    {
      name: "title",
      label: "Title",
      type: "string",
      required: true,
      showInList: true,
      showInShow: true,
      showInForm: true,
      sortable: true,
      searchable: true,
      placeholder: "Enter title",
      helpText: "The main title of the {entity}",
    },
    {
      name: "status",
      label: "Status",
      type: "select",
      required: true,
      showInList: true,
      showInShow: true,
      showInForm: true,
      options: [
        { value: "draft", label: "Draft" },
        { value: "published", label: "Published" },
      ],
      render: (value) => {
        const isDraft = value === "draft";
        return (
          <span class={\`badge \${isDraft ? "badge-warning" : "badge-success"}\`}>
            {String(value)}
          </span>
        );
      },
    },
    {
      name: "createdAt",
      label: "Created At",
      type: "datetime",
      showInList: false,
      showInShow: true,
      showInForm: false,
    },
    {
      name: "updatedAt",
      label: "Updated At",
      type: "datetime",
      showInList: false,
      showInShow: true,
      showInForm: false,
    },
  ],

  // Permissions
  canCreate: true,
  canEdit: true,
  canDelete: true,
  canView: true,

  // Optional: Prevent deletion of certain records
  // isSystemRecord: (record) => record.isSystem === true,

  // Optional: For non-ID primary keys (e.g., slug, key)
  // getRouteParam: (record) => record.slug,
};
```

### Field Configuration Options

```typescript
interface FieldConfig {
  name: string; // Field name in data
  label: string; // Display label
  type: FieldType; // Field type (see below)

  // Visibility
  showInList?: boolean; // Show in table (default: true)
  showInShow?: boolean; // Show in detail page (default: true)
  showInForm?: boolean; // Show in forms (default: true)

  // Validation
  required?: boolean; // Required field
  validate?: (value) => string | undefined; // Custom validation

  // Table features
  sortable?: boolean; // Can sort by this column
  searchable?: boolean; // Can search by this field

  // Form options
  placeholder?: string; // Input placeholder
  helpText?: string; // Help text below input
  rows?: number; // Textarea rows (for type: "text")
  options?: Array<{ // For type: "select"
    value: string | number;
    label: string;
  }>;

  // Custom rendering
  render?: (value, record) => string | JSX.Element;
  format?: (value) => string;
}
```

### Supported Field Types

- `string` - Text input
- `text` - Textarea (multi-line)
- `number` - Number input
- `boolean` - Checkbox
- `date` - Date picker
- `datetime` - DateTime picker
- `email` - Email input
- `select` - Dropdown select (requires `options`)
- `json` - JSON textarea
- `status` - Status badge
- `badge` - Generic badge

---

## Template 2: List Page (index.tsx)

**File**: `routes/admin/{entities}/index.tsx`

```typescript
/**
 * {Entities} List Page
 * Uses generic CRUD system
 */

import { define } from "../../../utils.ts";
import { AdminLayout } from "@/components/layout/AdminLayout.tsx";
import { DataTable } from "@/components/admin/DataTable.tsx";
import { Pagination } from "@/components/admin/Pagination.tsx";
import { createCRUDHandlers } from "@/lib/admin/crud-handlers.ts";
import { {entity}Config } from "@/config/entities/{entities}.config.tsx";
import type { {Entity} } from "@/entities/{entities}/{entity}.types.ts";
import type { ListResponse } from "@/lib/admin/types.ts";

const handlers = createCRUDHandlers({entity}Config);

export const handler = define.handlers({
  GET: handlers.list,
});

export default define.page<typeof handler>(function {Entities}ListPage({ data }) {
  const { items, config, error } = data;
  const response = items as ListResponse<{Entity}>;

  const handleView = (record: {Entity}) => {
    window.location.href = \`/admin/\${config.name}/\${record[config.idField]}\`;
  };

  const handleEdit = (record: {Entity}) => {
    window.location.href = \`/admin/\${config.name}/\${record[config.idField]}/edit\`;
  };

  const handleDelete = async (record: {Entity}) => {
    if (!confirm(\`Are you sure you want to delete this \${config.singularName.toLowerCase()}?\`)) {
      return;
    }

    try {
      await config.service.delete(record[config.idField]);
      window.location.reload();
    } catch (error) {
      alert(
        error instanceof Error
          ? error.message
          : \`Failed to delete \${config.singularName.toLowerCase()}\`,
      );
    }
  };

  return (
    <AdminLayout currentPath={\`/admin/\${config.name}\`}>
      <div class="space-y-4">
        <div class="flex justify-between items-center">
          <div>
            <h1 class="text-3xl font-bold">{config.pluralName}</h1>
            <p class="text-base-content/60 mt-1">
              Manage your {config.pluralName.toLowerCase()}
            </p>
          </div>
          {config.canCreate !== false && (
            <a href={\`/admin/\${config.name}/new\`} class="btn btn-primary">
              Create New {config.singularName}
            </a>
          )}
        </div>

        {error && (
          <div class="alert alert-error">
            <span>{error}</span>
          </div>
        )}

        <div class="card bg-base-100 shadow-xl">
          <div class="card-body">
            <DataTable
              config={config}
              data={response.data}
              onView={handleView}
              onEdit={handleEdit}
              onDelete={handleDelete}
            />

            {response.pagination && (
              <Pagination
                pagination={response.pagination}
                basePath={\`/admin/\${config.name}\`}
              />
            )}
          </div>
        </div>
      </div>
    </AdminLayout>
  );
});
```

---

## Template 3: Show Page ([id].tsx)

**File**: `routes/admin/{entities}/[id].tsx` or `[key].tsx` for key-based

```typescript
/**
 * {Entity} Show Page
 * Uses generic ShowPage component
 */

import { define } from "../../../../utils.ts";
import { ShowPage } from "@/components/admin/ShowPage.tsx";
import { createCRUDHandlers } from "@/lib/admin/crud-handlers.ts";
import { {entity}Config } from "@/config/entities/{entities}.config.tsx";

const handlers = createCRUDHandlers({entity}Config);

export const handler = define.handlers({
  GET: handlers.show,
});

export default define.page<typeof handler>(function {Entity}ShowPageRoute({ data }) {
  return <ShowPage config={data.config} item={data.item} error={data.error} />;
});
```

---

## Template 4: Create Page (new.tsx)

**File**: `routes/admin/{entities}/new.tsx`

```typescript
/**
 * {Entity} Create Page
 * Uses generic form system
 */

import { define } from "../../../utils.ts";
import { AdminLayout } from "@/components/layout/AdminLayout.tsx";
import { GenericForm } from "@/components/admin/GenericForm.tsx";
import { createCRUDHandlers } from "@/lib/admin/crud-handlers.ts";
import { {entity}Config } from "@/config/entities/{entities}.config.ts";

const handlers = createCRUDHandlers({entity}Config);

export const handler = define.handlers({
  GET: handlers.createGet,
  POST: handlers.createPost,
});

export default define.page<typeof handler>(function {Entity}CreatePage({ data }) {
  const { config, error, errors, values } = data;

  return (
    <AdminLayout currentPath={\`/admin/\${config.name}\`}>
      <div class="space-y-6">
        <div class="flex justify-between items-center">
          <div>
            <h1 class="text-3xl font-bold">
              {config.createTitle || \`Create New \${config.singularName}\`}
            </h1>
            <p class="text-base-content/60 mt-1">
              Fill in the details below
            </p>
          </div>
          <a href={\`/admin/\${config.name}\`} class="btn btn-ghost">
            Cancel
          </a>
        </div>

        {error && (
          <div class="alert alert-error">
            <span>{error}</span>
          </div>
        )}

        <div class="card bg-base-100 shadow-xl">
          <div class="card-body">
            <GenericForm
              config={config}
              item={values}
              errors={errors}
              isEdit={false}
            />
          </div>
        </div>
      </div>
    </AdminLayout>
  );
});
```

---

## Template 5: Edit Page ([id]/edit.tsx)

**File**: `routes/admin/{entities}/[id]/edit.tsx` or `[key]/edit.tsx`

```typescript
/**
 * {Entity} Edit Page
 * Uses generic form system
 */

import { define } from "../../../../utils.ts";  // Adjust path for [id]/ subdirectory
import { AdminLayout } from "@/components/layout/AdminLayout.tsx";
import { GenericForm } from "@/components/admin/GenericForm.tsx";
import { createCRUDHandlers } from "@/lib/admin/crud-handlers.ts";
import { {entity}Config } from "@/config/entities/{entities}.config.ts";

const handlers = createCRUDHandlers({entity}Config);

export const handler = define.handlers({
  GET: handlers.editGet,
  POST: handlers.editPost,
});

export default define.page<typeof handler>(function {Entity}EditPage({ data }) {
  const { config, item, error, errors } = data;

  if (!item && !error) {
    return (
      <AdminLayout currentPath={\`/admin/\${config.name}\`}>
        <div class="alert alert-warning">
          <span>{config.singularName} not found</span>
        </div>
      </AdminLayout>
    );
  }

  const identifier = config.getRouteParam
    ? config.getRouteParam(item)
    : (item as Record<string, unknown>)?.[config.idField];

  return (
    <AdminLayout currentPath={\`/admin/\${config.name}\`}>
      <div class="space-y-6">
        <div class="flex justify-between items-center">
          <div>
            <h1 class="text-3xl font-bold">
              {config.editTitle || \`Edit \${config.singularName}\`}
            </h1>
            {config.displayField && item && (
              <p class="text-base-content/60 mt-1">
                {String((item as Record<string, unknown>)[config.displayField])}
              </p>
            )}
          </div>
          <a
            href={\`/admin/\${config.name}/\${identifier}\`}
            class="btn btn-ghost"
          >
            Cancel
          </a>
        </div>

        {error && (
          <div class="alert alert-error">
            <span>{error}</span>
          </div>
        )}

        {item && (
          <div class="card bg-base-100 shadow-xl">
            <div class="card-body">
              <GenericForm
                config={config}
                item={item}
                errors={errors}
                isEdit
              />
            </div>
          </div>
        )}
      </div>
    </AdminLayout>
  );
});
```

---

## Variable Substitution

When scaffolding, replace these placeholders:

| Placeholder  | Example | Description                    |
| ------------ | ------- | ------------------------------ |
| `{entity}`   | `post`  | Lowercase singular (camelCase) |
| `{Entity}`   | `Post`  | PascalCase singular            |
| `{entities}` | `posts` | Lowercase plural (camelCase)   |
| `{Entities}` | `Posts` | PascalCase plural              |
| `{ENTITIES}` | `POSTS` | Uppercase plural               |

## Key-based vs ID-based Routing

### ID-based (default)

- Primary key: `id` (number)
- Routes: `[id].tsx`, `[id]/edit.tsx`
- URL: `/admin/posts/123`

### Key-based

- Primary key: `key` or `slug` (string)
- Routes: `[key].tsx`, `[key]/edit.tsx`
- URL: `/admin/posts/my-post-slug`
- Config: Add `getRouteParam: (record) => record.key`

## Best Practices

1. **Define ALL fields** in config (even if not shown everywhere)
2. **Use type-specific rendering** for status/badges
3. **Add validation** for required fields
4. **Set permissions** (canCreate, canEdit, canDelete)
5. **Protect system records** with `isSystemRecord`
6. **Add help text** for complex fields
7. **Use searchable** for frequently searched fields
8. **Keep route files identical** - only change config import

## Example: Complete Entity

See `config/entities/articles.config.tsx` for a complete real-world example
with:

- Multiple field types
- Custom rendering
- Validation
- Permissions
- All display options

## Testing Checklist

After scaffolding, test:

- [ ] List page loads with data
- [ ] Pagination works (page 1, 2, page size change)
- [ ] View button shows detail page
- [ ] Edit button loads form with data
- [ ] Create form validates required fields
- [ ] Create form submits and redirects
- [ ] Edit form saves changes
- [ ] Delete confirms and removes record
- [ ] Auth check redirects to login
- [ ] All columns visible in table
- [ ] All fields visible in show page
- [ ] All form fields render correctly

---

**This pattern is battle-tested and production-ready for tstack-kit
scaffolding.**
