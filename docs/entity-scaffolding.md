# Entity Scaffolding

## Overview

The `tstack scaffold` command generates a complete MVC entity with tests in
seconds.

```bash
tstack scaffold <entity-name>
```

## Generated Files

For `tstack scaffold products`:

| File                     | Purpose                                |
| ------------------------ | -------------------------------------- |
| `product.model.ts`       | Drizzle schema definition              |
| `product.dto.ts`         | Zod validation schemas                 |
| `product.service.ts`     | Business logic (extends BaseService)   |
| `product.controller.ts`  | HTTP handlers (extends BaseController) |
| `product.route.ts`       | Public API routes                      |
| `product.admin.route.ts` | Admin panel routes                     |
| `product.test.ts`        | API endpoint tests                     |
| `product.admin.test.ts`  | Admin panel tests                      |

## File Structure

```text
src/entities/products/
├── product.model.ts
├── product.dto.ts
├── product.service.ts
├── product.controller.ts
├── product.route.ts
├── product.admin.route.ts
├── product.test.ts
└── product.admin.test.ts
```

## Customization

### Add Fields to Model

Edit `product.model.ts`:

```typescript
export const products = pgTable("products", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  price: numeric("price", { precision: 10, scale: 2 }).notNull(),
  // Add your fields here
  sku: varchar("sku", { length: 50 }).unique(),
  inStock: boolean("in_stock").default(true),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

### Add Validation

Edit `product.dto.ts`:

```typescript
export const createProductSchema = z.object({
  name: z.string().min(1).max(255),
  price: z.number().positive(),
  sku: z.string().min(3).max(50).optional(),
  inStock: z.boolean().default(true),
});
```

### Add Business Logic

Edit `product.service.ts`:

```typescript
export class ProductService extends BaseService<Product, CreateDTO, UpdateDTO> {
  protected override async beforeCreate(data: CreateDTO) {
    // Generate SKU if not provided
    if (!data.sku) {
      data.sku = `SKU-${Date.now()}`;
    }
    return data;
  }
}
```

## After Scaffolding

1. Run migration:

   ```bash
   deno task migrate:generate
   deno task migrate:run
   ```

2. Run tests:

   ```bash
   deno task test
   ```

3. Entity appears in Admin UI sidebar automatically.

---

## Design Philosophy: Why Scaffolding Works This Way

### The 8-File Pattern

Each scaffolded entity produces exactly 8 files. This is not accidental:

| File               | Responsibility                               |
| ------------------ | -------------------------------------------- |
| `*.model.ts`       | Single source of truth for database schema   |
| `*.dto.ts`         | Validation boundary (input sanitization)     |
| `*.service.ts`     | Business logic (pure, testable functions)    |
| `*.controller.ts`  | HTTP translation (requests to service calls) |
| `*.route.ts`       | Public API registration                      |
| `*.admin.route.ts` | Admin API registration                       |
| `*.test.ts`        | Public API verification                      |
| `*.admin.test.ts`  | Admin API verification                       |

**Why separate routes from controllers?**

Controllers handle HTTP logic. Routes define URL patterns and middleware chains.
This separation lets you:

- Mount the same controller at different paths
- Apply different middleware to public vs admin routes
- Keep route files scannable (just path definitions)

**Why two test files?**

Public and admin APIs have different authentication requirements, different
response shapes, and different test fixtures. Separate files mean focused tests
that run faster and fail with clearer messages.

### Tests Generated by Default

Every scaffold includes working tests. This is deliberate:

1. **Tests are documentation** - The test file shows exactly how to call each
   endpoint with example payloads.

2. **Tests catch regressions** - As you customize the entity, tests verify you
   did not break existing behavior.

3. **Tests enable refactoring** - Want to change the service implementation? Run
   tests, refactor, run tests again.

4. **Tests are hard to add later** - If tests are not there from the start, they
   never get written. Scaffolding them eliminates the activation energy.

The generated tests use real database connections (no mocks) so they catch
actual issues like constraint violations and query errors.

### Why Services Extend BaseService

The scaffolded service extends `BaseService`:

```typescript
export class ProductService extends BaseService<Product, CreateDTO, UpdateDTO> {
  // Your customizations here
}
```

**What BaseService provides:**

- Standard CRUD operations (create, findById, findAll, update, delete)
- Pagination with cursor and offset support
- Lifecycle hooks (beforeCreate, afterCreate, beforeUpdate, afterUpdate, etc.)
- Soft delete support if `deletedAt` column exists
- Transaction handling

**What you add:**

- Domain-specific business logic
- Lifecycle hook implementations
- Custom queries and operations

This follows the 80/20 rule: 80% of entity operations are standard CRUD. Let
BaseService handle those. You focus on the 20% that makes your entity unique.

### Why Controllers Extend BaseController

Same principle for controllers:

```typescript
export class ProductController extends BaseController<
  Product,
  CreateDTO,
  UpdateDTO
> {
  // Your customizations here
}
```

**What BaseController provides:**

- HTTP handling for all CRUD operations
- Request validation using your DTO schemas
- Consistent response formatting
- Error transformation (service errors to HTTP errors)
- OpenAPI schema generation hooks

**The HTTP translation pattern:**

Controllers do not contain business logic. They translate:

```text
HTTP Request -> DTO validation -> Service method call -> HTTP Response
```

This keeps business logic testable without HTTP, and HTTP handling consistent
across entities.

### The Singular/Plural Naming Convention

When you scaffold `products`, the generator creates:

- Table: `products` (plural, as is convention for SQL tables)
- Model export: `products` (plural, matches table)
- Type: `Product` (singular, represents one row)
- Folder: `products` (plural, contains the entity)
- Files: `product.*.ts` (singular, each file handles one product concept)

**Why this inconsistency?**

It matches how developers think:

- "The products table" (plural) - you query many
- "A product record" (singular) - you handle one
- "The product service" (singular) - service for handling products
- "Products folder" (plural) - all product-related code

Consistent singular everywhere (`product` table, `product` folder) looks cleaner
but confuses developers. We match expectations over consistency.

### Why Admin Routes Are Separate

Admin routes live in `*.admin.route.ts`, not merged with public routes:

```typescript
// product.route.ts - Public API
app.get("/products", productController.findAll);
app.get("/products/:id", productController.findById);

// product.admin.route.ts - Admin API
app.get("/admin/api/products", adminAuth, productController.adminFindAll);
app.post("/admin/api/products", adminAuth, productController.adminCreate);
app.patch("/admin/api/products/:id", adminAuth, productController.adminUpdate);
app.delete("/admin/api/products/:id", adminAuth, productController.adminDelete);
```

**Reasons for separation:**

1. **Different middleware stacks** - Admin routes require authentication; public
   routes might not.

2. **Different response shapes** - Admin responses include metadata (audit
   timestamps, soft delete status). Public responses are cleaner.

3. **Different permissions** - Admin users have full CRUD. Public users might
   only read.

4. **Easier to remove** - Use `--skip-admin` and you do not touch public routes
   at all.

### The --skip-admin Decision Tree

The scaffold command defaults to generating admin routes. Here is when to use
each:

**Generate admin routes (default):**

```bash
tstack scaffold articles
```

Use for:

- Content managed by administrators
- Lookup tables edited occasionally
- Any entity appearing in admin sidebar

**Skip admin routes:**

```bash
tstack scaffold audit_logs --skip-admin
```

Use for:

- System-generated data (logs, events, metrics)
- Transient data (sessions, carts, caches)
- Entities managed through custom workflows
- Internal join tables

### Customization Points

After scaffolding, you customize in specific places:

**Model (schema changes):**

```typescript
// product.model.ts - Add columns
export const products = pgTable("products", {
  // ... existing columns
  categoryId: integer("category_id").references(() => categories.id),
});
```

**DTO (validation changes):**

```typescript
// product.dto.ts - Add validation
export const createProductSchema = z.object({
  name: z.string().min(1).max(255),
  price: z.number().positive().max(999999.99),
  categoryId: z.number().int().positive().optional(),
});
```

**Service (business logic):**

```typescript
// product.service.ts - Add behavior
protected override async beforeCreate(data: CreateDTO) {
  if (!data.slug) {
    data.slug = slugify(data.name);
  }
  return data;
}
```

**Controller (HTTP customization):**

```typescript
// product.controller.ts - Add endpoints
async featured(c: Context) {
  const products = await this.service.findFeatured();
  return c.json({ data: products });
}
```

**Routes (URL changes):**

```typescript
// product.route.ts - Add routes
app.get("/products/featured", productController.featured);
```

This layered approach means simple changes stay simple (edit one file), while
complex changes are possible (edit multiple files in predictable ways).

### Why No Code Generation Tool

Some frameworks generate code through CLI prompts:

```bash
# Other frameworks
npx prisma migrate dev --name add_products
npx nest generate controller products
```

TStack does not generate code this way. The scaffold command copies templates
from the starter kit, which means:

1. **Templates are readable** - Look at
   `packages/api-starter/src/entities/_template/` to see exactly what gets
   generated.

2. **Templates are customizable** - Fork the kit, modify templates, use your
   version.

3. **No magic** - The scaffold command is under 200 lines. You can read and
   understand it completely.

4. **Version controlled** - Templates are in Git. You can see when they changed
   and why.

The cost is some complexity in the scaffold command. The benefit is complete
transparency in what code you receive.
